-- TreshTalk Supabase Schema
-- This script is idempotent and can be run multiple times safely.

-- NOTE FOR EMAIL VERIFICATION:
-- For the registration flow to work correctly, you MUST enable email confirmations in your Supabase project.
-- Go to: Authentication -> Providers -> Email -> and toggle on "Enable Email confirmations".

-- ----------------------------------------
-- TABLE: profiles
-- Stores public user data.
-- ----------------------------------------
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    full_name TEXT,
    avatar_url TEXT,
    country TEXT,
    role TEXT
);
COMMENT ON TABLE public.profiles IS 'Stores public-facing profile information for each user.';

-- ----------------------------------------
-- TABLE: plans
-- Stores subscription plan details.
-- ----------------------------------------
CREATE TABLE IF NOT EXISTS public.plans (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    price_monthly INT NOT NULL,
    features TEXT[]
);
COMMENT ON TABLE public.plans IS 'Defines the available subscription plans and their features.';

-- ----------------------------------------
-- TABLE: features
-- Defines all possible features in the system.
-- ----------------------------------------
CREATE TABLE IF NOT EXISTS public.features (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    feature_key TEXT UNIQUE NOT NULL,
    name TEXT NOT NULL,
    description TEXT
);
COMMENT ON TABLE public.features IS 'A registry of all toggleable features in the application.';

-- ----------------------------------------
-- TABLE: plan_features
-- Links features to specific plans.
-- ----------------------------------------
CREATE TABLE IF NOT EXISTS public.plan_features (
    plan_id UUID NOT NULL REFERENCES public.plans(id) ON DELETE CASCADE,
    feature_id UUID NOT NULL REFERENCES public.features(id) ON DELETE CASCADE,
    PRIMARY KEY (plan_id, feature_id)
);
COMMENT ON TABLE public.plan_features IS 'Associates features with subscription plans.';

-- ----------------------------------------
-- TABLE: workspaces
-- Represents a user's company or workspace.
-- ----------------------------------------
CREATE TABLE IF NOT EXISTS public.workspaces (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    owner_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    company_name TEXT,
    industry TEXT,
    company_size TEXT,
    user_role TEXT,
    widget_id TEXT UNIQUE NOT NULL DEFAULT extensions.uuid_generate_v4()::text,
    plan_id UUID REFERENCES public.plans(id),
    created_at TIMESTAMPTZ DEFAULT now()
);
COMMENT ON TABLE public.workspaces IS 'Represents a customer''s workspace, containing their settings and data.';

-- ----------------------------------------
-- TABLE: workspace_users
-- Links users to workspaces (for team functionality).
-- ----------------------------------------
CREATE TABLE IF NOT EXISTS public.workspace_users (
    workspace_id UUID NOT NULL REFERENCES public.workspaces(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    role TEXT NOT NULL DEFAULT 'agent', -- e.g., 'admin', 'agent'
    PRIMARY KEY (workspace_id, user_id)
);
COMMENT ON TABLE public.workspace_users IS 'Maps users to the workspaces they belong to.';

-- ----------------------------------------
-- OTHER TABLES (Conversations, Messages, etc.)
-- ----------------------------------------
CREATE TABLE IF NOT EXISTS public.conversations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workspace_id UUID NOT NULL REFERENCES public.workspaces(id) ON DELETE CASCADE,
    visitor_id TEXT NOT NULL,
    visitor_email TEXT,
    status TEXT DEFAULT 'open',
    created_at TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE IF NOT EXISTS public.messages (
    id BIGSERIAL PRIMARY KEY,
    conversation_id UUID NOT NULL REFERENCES public.conversations(id) ON DELETE CASCADE,
    workspace_id UUID NOT NULL REFERENCES public.workspaces(id) ON DELETE CASCADE,
    sender_id UUID REFERENCES auth.users(id),
    sender_type TEXT NOT NULL, -- 'agent', 'visitor', 'bot'
    content TEXT,
    image_url TEXT,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- Dynamic Content Tables
CREATE TABLE IF NOT EXISTS public.blog_posts ( id BIGSERIAL PRIMARY KEY, slug TEXT UNIQUE, title TEXT, excerpt TEXT, author TEXT, published_at TIMESTAMPTZ, image_url TEXT );
CREATE TABLE IF NOT EXISTS public.automations ( id BIGSERIAL PRIMARY KEY, workspace_id UUID REFERENCES public.workspaces(id), name TEXT, description TEXT, is_active BOOLEAN );
CREATE TABLE IF NOT EXISTS public.kb_articles ( id BIGSERIAL PRIMARY KEY, workspace_id UUID REFERENCES public.workspaces(id), title TEXT, category TEXT, status TEXT, last_updated_at TIMESTAMPTZ );

-- Super Admin Tables
CREATE TABLE IF NOT EXISTS public.invoices ( id BIGSERIAL PRIMARY KEY, workspace_id UUID REFERENCES public.workspaces(id), amount INT, status TEXT, created_at TIMESTAMPTZ );
CREATE TABLE IF NOT EXISTS public.transactions ( id BIGSERIAL PRIMARY KEY, workspace_id UUID REFERENCES public.workspaces(id), amount INT, type TEXT, created_at TIMESTAMPTZ );
CREATE TABLE IF NOT EXISTS public.announcements ( id BIGSERIAL PRIMARY KEY, title TEXT, content TEXT, created_at TIMESTAMPTZ DEFAULT now() );
CREATE TABLE IF NOT EXISTS public.audit_log ( id BIGSERIAL PRIMARY KEY, user_id UUID REFERENCES auth.users(id), action TEXT, created_at TIMESTAMPTZ DEFAULT now() );


-- ----------------------------------------
-- RLS (ROW LEVEL SECURITY) POLICIES
-- This is the most critical part for security.
-- ----------------------------------------

-- Policies for PROFILES
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users can view their own profile." ON public.profiles;
CREATE POLICY "Users can view their own profile." ON public.profiles FOR SELECT USING (auth.uid() = id);
DROP POLICY IF EXISTS "Users can update their own profile." ON public.profiles;
CREATE POLICY "Users can update their own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id) WITH CHECK (auth.uid() = id);
DROP POLICY IF EXISTS "Users can see profiles of their teammates." ON public.profiles;
CREATE POLICY "Users can see profiles of their teammates." ON public.profiles FOR SELECT USING (
  id IN (
    SELECT user_id FROM public.workspace_users WHERE workspace_id IN (
      SELECT workspace_id FROM public.workspace_users WHERE user_id = auth.uid()
    )
  )
);

-- Policies for WORKSPACES
ALTER TABLE public.workspaces ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users can view their own workspace." ON public.workspaces;
CREATE POLICY "Users can view their own workspace." ON public.workspaces FOR SELECT USING (
  id IN (SELECT workspace_id FROM public.workspace_users WHERE user_id = auth.uid())
);
DROP POLICY IF EXISTS "Public can read workspaces for widget config." ON public.workspaces;
CREATE POLICY "Public can read workspaces for widget config." ON public.workspaces FOR SELECT TO anon USING (true);


-- Policies for WORKSPACE_USERS
ALTER TABLE public.workspace_users ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users can see their own membership." ON public.workspace_users;
CREATE POLICY "Users can see their own membership." ON public.workspace_users FOR SELECT USING (user_id = auth.uid());
DROP POLICY IF EXISTS "Admins can manage their workspace members." ON public.workspace_users;
CREATE POLICY "Admins can manage their workspace members." ON public.workspace_users FOR ALL USING (
    workspace_id IN (
        SELECT workspace_id FROM public.workspace_users WHERE user_id = auth.uid() AND role = 'admin'
    )
);

-- Policies for CONVERSATIONS
ALTER TABLE public.conversations ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users can access conversations in their workspace." ON public.conversations;
CREATE POLICY "Users can access conversations in their workspace." ON public.conversations FOR ALL USING (
  workspace_id IN (SELECT workspace_id FROM public.workspace_users WHERE user_id = auth.uid())
);
DROP POLICY IF EXISTS "Allow anonymous access for widget." ON public.conversations;
CREATE POLICY "Allow anonymous access for widget." ON public.conversations FOR ALL TO anon USING (true);

-- Policies for MESSAGES
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users can access messages in their workspace." ON public.messages;
CREATE POLICY "Users can access messages in their workspace." ON public.messages FOR ALL USING (
  workspace_id IN (SELECT workspace_id FROM public.workspace_users WHERE user_id = auth.uid())
);
DROP POLICY IF EXISTS "Allow anonymous access for widget." ON public.messages;
CREATE POLICY "Allow anonymous access for widget." ON public.messages FOR ALL TO anon USING (true);


-- Policies for DYNAMIC CONTENT
ALTER TABLE public.plans ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Plans are publicly viewable." ON public.plans;
CREATE POLICY "Plans are publicly viewable." ON public.plans FOR SELECT TO anon, authenticated USING (true);

ALTER TABLE public.blog_posts ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Blog posts are publicly viewable." ON public.blog_posts;
CREATE POLICY "Blog posts are publicly viewable." ON public.blog_posts FOR SELECT USING (true);

ALTER TABLE public.automations ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users can manage automations in their workspace." ON public.automations;
CREATE POLICY "Users can manage automations in their workspace." ON public.automations FOR ALL USING (
  workspace_id IN (SELECT workspace_id FROM public.workspace_users WHERE user_id = auth.uid())
);

ALTER TABLE public.kb_articles ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users can manage KB articles in their workspace." ON public.kb_articles;
CREATE POLICY "Users can manage KB articles in their workspace." ON public.kb_articles FOR ALL USING (
  workspace_id IN (SELECT workspace_id FROM public.workspace_users WHERE user_id = auth.uid())
);


-- ----------------------------------------
-- STORAGE POLICIES
-- ----------------------------------------
-- Create bucket if it doesn't exist
-- Note: Bucket creation cannot be done in SQL, must be done in Supabase UI or with management API.
-- This script assumes a bucket named 'images' exists and is public.

-- Policy for viewing images
DROP POLICY IF EXISTS "Public Read Access" ON storage.objects;
CREATE POLICY "Public Read Access" ON storage.objects FOR SELECT USING ( bucket_id = 'images' );

-- Policy for uploading images
DROP POLICY IF EXISTS "Authenticated Upload" ON storage.objects;
CREATE POLICY "Authenticated Upload" ON storage.objects FOR INSERT WITH CHECK ( bucket_id = 'images' AND auth.role() = 'authenticated' );

-- Policy for updating/deleting own images
DROP POLICY IF EXISTS "Allow update/delete of own images" ON storage.objects;
CREATE POLICY "Allow update/delete of own images" ON storage.objects FOR UPDATE USING ( auth.uid() = owner ) WITH CHECK ( auth.uid() = owner );


-- ----------------------------------------
-- DATABASE FUNCTIONS & TRIGGERS
-- ----------------------------------------

-- Function to create a profile, workspace, and assign roles when a new user signs up
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  new_workspace_id UUID;
  free_plan_id UUID;
BEGIN
  -- Create a public profile
  INSERT INTO public.profiles (id, full_name, role, country)
  VALUES (
    NEW.id,
    NEW.raw_user_meta_data->>'full_name',
    NEW.raw_user_meta_data->>'user_role',
    NEW.raw_user_meta_data->>'country'
  );

  -- Find the ID of the default 'Free' plan
  SELECT id INTO free_plan_id FROM public.plans WHERE name = 'Free' LIMIT 1;

  -- Create a workspace for the new user
  INSERT INTO public.workspaces (owner_id, company_name, industry, company_size, user_role, plan_id)
  VALUES (
    NEW.id,
    NEW.raw_user_meta_data->>'company_name',
    NEW.raw_user_meta_data->>'industry',
    NEW.raw_user_meta_data->>'company_size',
    NEW.raw_user_meta_data->>'user_role',
    free_plan_id
  ) RETURNING id INTO new_workspace_id;

  -- Add the user to their own workspace as an admin
  INSERT INTO public.workspace_users (workspace_id, user_id, role)
  VALUES (new_workspace_id, NEW.id, 'admin');

  RETURN NEW;
END;
$$;

-- Trigger to execute the function on new user creation
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();


-- Function to get session data securely
CREATE OR REPLACE FUNCTION public.get_user_session_data()
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    _user_id UUID := auth.uid();
    _profile RECORD;
    _workspace RECORD;
    _features TEXT[];
BEGIN
    SELECT * INTO _profile FROM public.profiles WHERE id = _user_id;
    
    SELECT w.* INTO _workspace
    FROM public.workspaces w
    JOIN public.workspace_users wu ON w.id = wu.workspace_id
    WHERE wu.user_id = _user_id
    LIMIT 1;

    SELECT array_agg(f.feature_key) INTO _features
    FROM public.plan_features pf
    JOIN public.features f ON pf.feature_id = f.id
    WHERE pf.plan_id = _workspace.plan_id;

    RETURN json_build_object(
        'profile', row_to_json(_profile),
        'workspace', row_to_json(_workspace),
        'features', COALESCE(_features, '{}')
    );
END;
$$;
-- Grant execute permission to authenticated users
GRANT EXECUTE ON FUNCTION public.get_user_session_data() TO authenticated;


-- Analytics Functions
CREATE OR REPLACE FUNCTION public.get_workspace_chat_stats(p_workspace_id UUID, p_period TEXT)
RETURNS JSON
LANGUAGE plpgsql
AS $$
DECLARE
    _result JSON;
    _start_date TIMESTAMPTZ;
BEGIN
    IF p_period = 'week' THEN
        _start_date := date_trunc('week', now());
    ELSIF p_period = 'month' THEN
        _start_date := date_trunc('month', now());
    ELSIF p_period = 'year' THEN
        _start_date := date_trunc('year', now());
    ELSE
        _start_date := '1970-01-01'; -- All time
    END IF;

    SELECT json_build_object(
        'total_chats', COUNT(*)
        -- Add more stats here
    ) INTO _result
    FROM public.conversations
    WHERE workspace_id = p_workspace_id AND created_at >= _start_date;
    
    RETURN _result;
END;
$$;
GRANT EXECUTE ON FUNCTION public.get_workspace_chat_stats(UUID, TEXT) TO authenticated;

CREATE OR REPLACE FUNCTION public.get_visitors_by_workspace(p_workspace_id UUID)
RETURNS TABLE(visitor_id TEXT, visitor_email TEXT, last_seen TIMESTAMPTZ)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        c.visitor_id, 
        MAX(c.visitor_email) as visitor_email,
        MAX(c.created_at) as last_seen
    FROM public.conversations c
    WHERE c.workspace_id = p_workspace_id
    GROUP BY c.visitor_id
    ORDER BY last_seen DESC;
END;
$$;
GRANT EXECUTE ON FUNCTION public.get_visitors_by_workspace(UUID) TO authenticated;

CREATE OR REPLACE FUNCTION public.get_platform_stats()
RETURNS JSON
LANGUAGE plpgsql
AS $$
DECLARE
    _result JSON;
BEGIN
    SELECT json_build_object(
        'total_users', (SELECT COUNT(*) FROM auth.users),
        'total_workspaces', (SELECT COUNT(*) FROM public.workspaces),
        'mrr', 0, -- Placeholder
        'active_subscriptions', 0 -- Placeholder
    ) INTO _result;
    RETURN _result;
END;
$$;
-- NOTE: In a real app, restrict this to superadmins. For the demo, we allow authenticated.
GRANT EXECUTE ON FUNCTION public.get_platform_stats() TO authenticated;

-- ----------------------------------------
-- SEED DATA (for initial setup)
-- ----------------------------------------

-- Seed Features
INSERT INTO public.features (feature_key, name, description) VALUES
('has_reports', 'Reporting', 'Access to the analytics and reports page.'),
('has_automations', 'Automations', 'Create and manage automated chat triggers.'),
('has_kb', 'Knowledge Base', 'Create and manage a self-service knowledge base.'),
('has_team', 'Team Management', 'Invite and manage team members.'),
('has_integrations', 'Integrations', 'Connect with third-party applications.'),
('has_movable_widget', 'Movable Widget', 'Allows visitors to reposition the chat widget.'),
('has_advanced_widget_customization', 'Advanced Customization', 'More detailed widget appearance options.')
ON CONFLICT (feature_key) DO NOTHING;

-- Seed Plans
DO $$
DECLARE
    free_plan_id UUID;
    pro_plan_id UUID;
    business_plan_id UUID;
    reports_feature_id UUID;
    automations_feature_id UUID;
    kb_feature_id UUID;
    movable_widget_feature_id UUID;
BEGIN
    -- Insert plans and get their IDs
    INSERT INTO public.plans (name, price_monthly, features) VALUES
    ('Free', 0, ARRAY['1 Agent Seat', '100 Chats/mo', 'Basic Widget Customization'])
    ON CONFLICT (name) DO UPDATE SET price_monthly = 0, features = ARRAY['1 Agent Seat', '100 Chats/mo', 'Basic Widget Customization']
    RETURNING id INTO free_plan_id;

    INSERT INTO public.plans (name, price_monthly, features) VALUES
    ('Pro', 4900, ARRAY['5 Agent Seats', '1,000 Chats/mo', 'Reporting & Analytics', 'Automations', 'Knowledge Base'])
    ON CONFLICT (name) DO UPDATE SET price_monthly = 4900, features = ARRAY['5 Agent Seats', '1,000 Chats/mo', 'Reporting & Analytics', 'Automations', 'Knowledge Base']
    RETURNING id INTO pro_plan_id;
    
    INSERT INTO public.plans (name, price_monthly, features) VALUES
    ('Business', 9900, ARRAY['Unlimited Seats', '10,000 Chats/mo', 'Everything in Pro', 'Team Management', 'API Access'])
    ON CONFLICT (name) DO UPDATE SET price_monthly = 9900, features = ARRAY['Unlimited Seats', '10,000 Chats/mo', 'Everything in Pro', 'Team Management', 'API Access']
    RETURNING id INTO business_plan_id;

    -- Get feature IDs
    SELECT id INTO reports_feature_id FROM public.features WHERE feature_key = 'has_reports';
    SELECT id INTO automations_feature_id FROM public.features WHERE feature_key = 'has_automations';
    SELECT id INTO kb_feature_id FROM public.features WHERE feature_key = 'has_kb';
    SELECT id INTO movable_widget_feature_id FROM public.features WHERE feature_key = 'has_movable_widget';

    -- Link features to plans
    -- Pro Plan
    INSERT INTO public.plan_features (plan_id, feature_id) VALUES (pro_plan_id, reports_feature_id), (pro_plan_id, automations_feature_id), (pro_plan_id, kb_feature_id), (pro_plan_id, movable_widget_feature_id) ON CONFLICT DO NOTHING;

    -- Business Plan (gets all of pro's features + more)
    INSERT INTO public.plan_features (plan_id, feature_id) VALUES (business_plan_id, reports_feature_id), (business_plan_id, automations_feature_id), (business_plan_id, kb_feature_id), (business_plan_id, movable_widget_feature_id) ON CONFLICT DO NOTHING;

END $$;


-- Seed Blog Posts (for demo)
INSERT INTO public.blog_posts (slug, title, excerpt, author, published_at, image_url) VALUES
('5-ways-ai-can-boost-sales', '5 Ways AI Chatbots Can Boost Your Sales', 'Discover how implementing an AI chatbot can not only improve customer service but also have a direct impact on your bottom line.', 'Jane Doe', '2024-08-05', 'https://picsum.photos/seed/sales-boost/800/600')
ON CONFLICT (slug) DO NOTHING;


-- ----------------------------------------
-- DEMO SETUP (Run this AFTER creating a demo user)
-- ----------------------------------------
-- IMPORTANT:
-- 1. Use the Register page in your app to create a user with the email: user@example.com
-- 2. Check your email and click the verification link.
-- 3. ONLY after the user is verified, run the following command in the SQL Editor.

-- UPDATE public.workspaces
-- SET widget_id = 'demo-widget-id'
-- WHERE owner_id = (SELECT id FROM auth.users WHERE email = 'user@example.com');