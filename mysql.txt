-- This script is designed to be idempotent (runnable multiple times without errors)
-- and sets up the complete database schema for the TreshTalk application.

-- 
-- IMPORTANT: EMAIL VERIFICATION SETUP
-- For the registration flow to work, you MUST enable email confirmations in your Supabase project.
-- Go to: Authentication -> Providers -> Email -> Enable "Email confirmations".
-- Also, configure your email provider settings in: Authentication -> SMTP Settings.
-- 

-- 1. Enable UUID extension if not enabled
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- =============================================
-- SECTION 1: TABLE CREATION
-- =============================================

-- PROFILES TABLE
-- Stores public user data.
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    full_name TEXT,
    email TEXT,
    avatar_url TEXT,
    country TEXT
);
COMMENT ON TABLE public.profiles IS 'Stores public-facing profile information for each user.';

-- PLANS TABLE
-- Stores subscription plan details.
CREATE TABLE IF NOT EXISTS public.plans (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL UNIQUE,
    price_monthly INT NOT NULL,
    features TEXT[]
);
COMMENT ON TABLE public.plans IS 'Defines the available subscription plans and their features.';

-- FEATURES TABLE
-- Defines all available features that can be toggled per plan.
CREATE TABLE IF NOT EXISTS public.features (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    key TEXT NOT NULL UNIQUE,
    name TEXT NOT NULL,
    description TEXT
);
COMMENT ON TABLE public.features IS 'Lists all toggleable features in the system.';

-- PLAN_FEATURES TABLE (Join Table)
-- Links features to specific plans.
CREATE TABLE IF NOT EXISTS public.plan_features (
    plan_id UUID NOT NULL REFERENCES public.plans(id) ON DELETE CASCADE,
    feature_id UUID NOT NULL REFERENCES public.features(id) ON DELETE CASCADE,
    PRIMARY KEY (plan_id, feature_id)
);
COMMENT ON TABLE public.plan_features IS 'Associates features with subscription plans.';

-- WORKSPACES TABLE
-- Stores information about a user's company or workspace.
CREATE TABLE IF NOT EXISTS public.workspaces (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    owner_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    company_name TEXT,
    widget_id TEXT UNIQUE NOT NULL,
    created_at TIMESTAMPTZ DEFAULT now(),
    industry TEXT,
    company_size TEXT,
    user_role TEXT,
    plan_id UUID REFERENCES public.plans(id)
);
COMMENT ON TABLE public.workspaces IS 'Represents a single client account or company.';

-- WORKSPACE_USERS TABLE (Join Table)
-- Links multiple users to a single workspace for team features.
CREATE TABLE IF NOT EXISTS public.workspace_users (
    workspace_id UUID NOT NULL REFERENCES public.workspaces(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    role TEXT NOT NULL DEFAULT 'agent', -- e.g., 'owner', 'admin', 'agent'
    PRIMARY KEY (workspace_id, user_id)
);
COMMENT ON TABLE public.workspace_users IS 'Manages team members within a workspace.';

-- CONVERSATIONS TABLE
-- Stores chat conversations.
CREATE TABLE IF NOT EXISTS public.conversations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workspace_id UUID NOT NULL REFERENCES public.workspaces(id) ON DELETE CASCADE,
    visitor_id TEXT NOT NULL,
    visitor_email TEXT,
    status TEXT DEFAULT 'open', -- 'open', 'pending', 'closed'
    created_at TIMESTAMPTZ DEFAULT now()
);
COMMENT ON TABLE public.conversations IS 'A single chat session with a website visitor.';

-- MESSAGES TABLE
-- Stores individual chat messages.
CREATE TABLE IF NOT EXISTS public.messages (
    id BIGSERIAL PRIMARY KEY,
    conversation_id UUID NOT NULL REFERENCES public.conversations(id) ON DELETE CASCADE,
    workspace_id UUID NOT NULL REFERENCES public.workspaces(id) ON DELETE CASCADE,
    sender_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- agent's user_id
    sender_type TEXT NOT NULL, -- 'agent', 'visitor', 'bot'
    content TEXT,
    image_url TEXT,
    created_at TIMESTAMPTZ DEFAULT now()
);
COMMENT ON TABLE public.messages IS 'An individual message within a conversation.';

-- OTHER DYNAMIC CONTENT TABLES
CREATE TABLE IF NOT EXISTS public.blog_posts ( id BIGSERIAL PRIMARY KEY, slug TEXT UNIQUE, title TEXT, excerpt TEXT, content TEXT, author TEXT, published_at TIMESTAMPTZ, image_url TEXT );
CREATE TABLE IF NOT EXISTS public.automations ( id BIGSERIAL PRIMARY KEY, workspace_id UUID REFERENCES public.workspaces(id), name TEXT, description TEXT, is_active BOOLEAN );
CREATE TABLE IF NOT EXISTS public.kb_articles ( id BIGSERIAL PRIMARY KEY, workspace_id UUID REFERENCES public.workspaces(id), title TEXT, content TEXT, category TEXT, status TEXT, last_updated_at TIMESTAMPTZ );
CREATE TABLE IF NOT EXISTS public.invoices ( id BIGSERIAL PRIMARY KEY, workspace_id UUID REFERENCES public.workspaces(id), amount INT, status TEXT, created_at TIMESTAMPTZ );
CREATE TABLE IF NOT EXISTS public.transactions ( id BIGSERIAL PRIMARY KEY, invoice_id BIGINT REFERENCES public.invoices(id), amount INT, type TEXT, created_at TIMESTAMPTZ );
CREATE TABLE IF NOT EXISTS public.announcements ( id BIGSERIAL PRIMARY KEY, title TEXT, content TEXT, created_at TIMESTAMPTZ );
CREATE TABLE IF NOT EXISTS public.audit_log ( id BIGSERIAL PRIMARY KEY, user_id UUID REFERENCES auth.users(id), action TEXT, details JSONB, created_at TIMESTAMPTZ );


-- =============================================
-- SECTION 2: ROW LEVEL SECURITY (RLS)
-- =============================================

-- Helper function to get user's workspace
CREATE OR REPLACE FUNCTION public.get_user_workspace_id(p_user_id UUID)
RETURNS UUID AS $$
DECLARE
    workspace_uuid UUID;
BEGIN
    SELECT workspace_id INTO workspace_uuid FROM public.workspace_users WHERE user_id = p_user_id LIMIT 1;
    RETURN workspace_uuid;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- PROFILES RLS
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users can view their own profile." ON public.profiles;
CREATE POLICY "Users can view their own profile." ON public.profiles FOR SELECT USING (auth.uid() = id);
DROP POLICY IF EXISTS "Users can update their own profile." ON public.profiles;
CREATE POLICY "Users can update their own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);
DROP POLICY IF EXISTS "Users can view profiles of their teammates." ON public.profiles;
CREATE POLICY "Users can view profiles of their teammates." ON public.profiles FOR SELECT USING (
    id IN (SELECT user_id FROM public.workspace_users WHERE workspace_id = public.get_user_workspace_id(auth.uid()))
);


-- WORKSPACES RLS
ALTER TABLE public.workspaces ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users can view their own workspace." ON public.workspaces;
CREATE POLICY "Users can view their own workspace." ON public.workspaces FOR SELECT USING (id = public.get_user_workspace_id(auth.uid()));
DROP POLICY IF EXISTS "Public anonymous access to find widget config." ON public.workspaces;
CREATE POLICY "Public anonymous access to find widget config." ON public.workspaces FOR SELECT TO anon USING (true);

-- CONVERSATIONS RLS
ALTER TABLE public.conversations ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users can manage conversations in their workspace." ON public.conversations;
CREATE POLICY "Users can manage conversations in their workspace." ON public.conversations FOR ALL USING (workspace_id = public.get_user_workspace_id(auth.uid()));

-- MESSAGES RLS
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users can manage messages in their workspace." ON public.messages;
CREATE POLICY "Users can manage messages in their workspace." ON public.messages FOR ALL USING (workspace_id = public.get_user_workspace_id(auth.uid()));

-- PLANS RLS
ALTER TABLE public.plans ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Plans are publicly readable" ON public.plans;
CREATE POLICY "Plans are publicly readable" ON public.plans FOR SELECT USING (true);

-- BLOG POSTS RLS
ALTER TABLE public.blog_posts ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Blog posts are publicly readable" ON public.blog_posts;
CREATE POLICY "Blog posts are publicly readable" ON public.blog_posts FOR SELECT USING (true);

-- Other tables that need basic RLS
ALTER TABLE public.automations ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users can manage automations in their workspace." ON public.automations;
CREATE POLICY "Users can manage automations in their workspace." ON public.automations FOR ALL USING (workspace_id = public.get_user_workspace_id(auth.uid()));

ALTER TABLE public.kb_articles ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users can manage KB articles in their workspace." ON public.kb_articles;
CREATE POLICY "Users can manage KB articles in their workspace." ON public.kb_articles FOR ALL USING (workspace_id = public.get_user_workspace_id(auth.uid()));

ALTER TABLE public.workspace_users ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users can view members of their own workspace" ON public.workspace_users;
CREATE POLICY "Users can view members of their own workspace" ON public.workspace_users FOR SELECT USING (workspace_id = public.get_user_workspace_id(auth.uid()));

-- =============================================
-- SECTION 3: DATABASE TRIGGERS & FUNCTIONS
-- =============================================

-- Function to create a profile and workspace for a new user
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
DECLARE
  _workspace_id UUID;
  _widget_id TEXT;
BEGIN
  -- Create a new workspace for the user
  _widget_id := substr(md5(random()::text), 0, 11);
  INSERT INTO public.workspaces (owner_id, company_name, industry, company_size, user_role, widget_id, plan_id)
  VALUES (
    NEW.id,
    NEW.raw_user_meta_data->>'company_name',
    NEW.raw_user_meta_data->>'industry',
    NEW.raw_user_meta_data->>'company_size',
    NEW.raw_user_meta_data->>'user_role',
    _widget_id,
    (SELECT id FROM public.plans WHERE price_monthly = 0 LIMIT 1)
  ) RETURNING id INTO _workspace_id;

  -- Create the user's profile
  INSERT INTO public.profiles (id, full_name, email, country)
  VALUES (
    NEW.id,
    NEW.raw_user_meta_data->>'full_name',
    NEW.email,
    NEW.raw_user_meta_data->>'country'
  );

  -- Add user to the workspace members
  INSERT INTO public.workspace_users (workspace_id, user_id, role)
  VALUES (
    _workspace_id,
    NEW.id,
    'owner'
  );

  RETURN NEW;
END;
$$;

-- Trigger to call the function on new user signup
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- Enable real-time for messages and conversations tables
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_publication_tables WHERE pubname = 'supabase_realtime' AND tablename = 'messages') THEN
    ALTER PUBLICATION supabase_realtime ADD TABLE public.messages;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_publication_tables WHERE pubname = 'supabase_realtime' AND tablename = 'conversations') THEN
    ALTER PUBLICATION supabase_realtime ADD TABLE public.conversations;
  END IF;
END $$;


-- =============================================
-- SECTION 4: STORAGE POLICIES
-- =============================================
-- Instructions for setting up Storage are in comments as they are done in the UI,
-- but the policies can be scripted.

-- BUCKET: images
-- 1. Create a bucket named "images" in the Supabase dashboard.
-- 2. Make the bucket PUBLIC.
-- 3. Run the following policies in the SQL editor.

DROP POLICY IF EXISTS "Public Read Access" ON storage.objects;
CREATE POLICY "Public Read Access" ON storage.objects FOR SELECT USING ( bucket_id = 'images' );

DROP POLICY IF EXISTS "Authenticated Upload Access" ON storage.objects;
CREATE POLICY "Authenticated Upload Access" ON storage.objects FOR INSERT WITH CHECK ( bucket_id = 'images' AND auth.role() = 'authenticated' );


-- =============================================
-- SECTION 5: RPC FUNCTIONS FOR ANALYTICS
-- =============================================

-- RPC to get user session data including feature flags
CREATE OR REPLACE FUNCTION public.get_user_session_data()
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
DECLARE
    _user_id UUID := auth.uid();
    _workspace_id UUID;
    _profile RECORD;
    _features TEXT[];
    _result JSON;
BEGIN
    SELECT w.id INTO _workspace_id
    FROM public.workspaces w
    JOIN public.workspace_users wu ON w.id = wu.workspace_id
    WHERE wu.user_id = _user_id LIMIT 1;

    SELECT id, full_name, avatar_url INTO _profile
    FROM public.profiles
    WHERE id = _user_id;

    SELECT array_agg(f.key) INTO _features
    FROM public.plan_features pf
    JOIN public.features f ON pf.feature_id = f.id
    JOIN public.workspaces w ON pf.plan_id = w.plan_id
    WHERE w.id = _workspace_id;

    _result := json_build_object(
        'profile', row_to_json(_profile),
        'workspaceId', _workspace_id,
        'features', COALESCE(_features, ARRAY[]::TEXT[])
    );

    RETURN _result;
END;
$$;
GRANT EXECUTE ON FUNCTION public.get_user_session_data() TO authenticated;


-- RPC for Super Admin dashboard stats
CREATE OR REPLACE FUNCTION public.get_platform_stats()
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
DECLARE
    _result JSON;
BEGIN
    -- NOTE: This is a placeholder for a real Super Admin.
    -- A real implementation would check if the caller has a 'superadmin' role.
    SELECT json_build_object(
        'total_users', (SELECT count(*) FROM auth.users),
        'total_workspaces', (SELECT count(*) FROM public.workspaces),
        'mrr', (SELECT COALESCE(SUM(p.price_monthly), 0) FROM public.workspaces w JOIN public.plans p ON w.plan_id = p.id),
        'active_subscriptions', (SELECT count(*) FROM public.workspaces w JOIN public.plans p ON w.plan_id = p.id WHERE p.price_monthly > 0)
    ) INTO _result;
    RETURN _result;
END;
$$;


-- RPC for User dashboard stats
CREATE OR REPLACE FUNCTION public.get_workspace_chat_stats(p_workspace_id UUID, p_period TEXT)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
DECLARE
    _result JSON;
    _start_date TIMESTAMPTZ;
BEGIN
    IF p_period = 'week' THEN
        _start_date := date_trunc('week', now());
    ELSIF p_period = 'month' THEN
        _start_date := date_trunc('month', now());
    ELSE -- Default to year
        _start_date := date_trunc('year', now());
    END IF;

    SELECT json_build_object(
        'total_chats', (SELECT COUNT(*) FROM public.conversations WHERE workspace_id = p_workspace_id AND created_at >= _start_date),
        'missed_chats', 0, -- Placeholder
        'avg_response_time', '1m 32s' -- Placeholder
    ) INTO _result;

    RETURN _result;
END;
$$;
GRANT EXECUTE ON FUNCTION public.get_workspace_chat_stats(UUID, TEXT) TO authenticated;


-- RPC to get visitors for a workspace
CREATE OR REPLACE FUNCTION public.get_visitors_by_workspace(p_workspace_id UUID)
RETURNS TABLE (visitor_id TEXT, visitor_email TEXT, last_seen TIMESTAMPTZ) AS $$
BEGIN
    RETURN QUERY
    SELECT
        c.visitor_id,
        MAX(c.visitor_email) as visitor_email,
        MAX(c.created_at) as last_seen
    FROM public.conversations c
    WHERE c.workspace_id = p_workspace_id
    GROUP BY c.visitor_id
    ORDER BY last_seen DESC;
END;
$$ LANGUAGE plpgsql;
GRANT EXECUTE ON FUNCTION public.get_visitors_by_workspace(UUID) TO authenticated;

-- RPC for public widget config
CREATE OR REPLACE FUNCTION public.get_widget_config(p_widget_id TEXT)
RETURNS JSON
LANGUAGE plpgsql
AS $$
DECLARE
    _workspace_id UUID;
    _features TEXT[];
    _result JSON;
BEGIN
    SELECT id INTO _workspace_id
    FROM public.workspaces
    WHERE widget_id = p_widget_id;
    
    IF _workspace_id IS NULL THEN
      RETURN NULL;
    END IF;

    SELECT array_agg(f.key) INTO _features
    FROM public.plan_features pf
    JOIN public.features f ON pf.feature_id = f.id
    JOIN public.workspaces w ON pf.plan_id = w.plan_id
    WHERE w.id = _workspace_id;

    _result := json_build_object(
        'workspaceId', _workspace_id,
        'features', COALESCE(_features, ARRAY[]::TEXT[])
    );

    RETURN _result;
END;
$$;
GRANT EXECUTE ON FUNCTION public.get_widget_config(TEXT) TO anon;

-- =============================================
-- SECTION 6: SEED DATA (INITIAL SETUP)
-- =============================================
-- This part seeds the database with initial plans and features.
-- It's safe to run multiple times.

DO $$
DECLARE
    free_plan_id UUID;
    pro_plan_id UUID;
    biz_plan_id UUID;
    reports_feature_id UUID;
    automations_feature_id UUID;
    movable_widget_feature_id UUID;
BEGIN
    -- Seed Plans
    INSERT INTO public.plans (name, price_monthly, features) VALUES
    ('Free', 0, ARRAY['1 Agent', 'Live Chat', '100 Contacts']),
    ('Pro', 25, ARRAY['Up to 5 Agents', 'Proactive Chat', 'Reporting']),
    ('Business', 79, ARRAY['Unlimited Agents', 'Automations', 'API Access'])
    ON CONFLICT (name) DO NOTHING;

    -- Seed Features
    INSERT INTO public.features (key, name, description) VALUES
    ('has_reports', 'Reporting', 'Access to the analytics and reports dashboard.'),
    ('has_automations', 'Automations', 'Create rules for proactive chat invitations.'),
    ('has_movable_widget', 'Movable Widget', 'Allows visitors to drag the chat widget to the left or right side of the screen.')
    ON CONFLICT (key) DO NOTHING;

    -- Get IDs
    SELECT id INTO free_plan_id FROM public.plans WHERE name = 'Free';
    SELECT id INTO pro_plan_id FROM public.plans WHERE name = 'Pro';
    SELECT id INTO biz_plan_id FROM public.plans WHERE name = 'Business';
    SELECT id INTO reports_feature_id FROM public.features WHERE key = 'has_reports';
    SELECT id INTO automations_feature_id FROM public.features WHERE key = 'has_automations';
    SELECT id INTO movable_widget_feature_id FROM public.features WHERE key = 'has_movable_widget';

    -- Link Features to Plans
    -- Pro Plan
    IF pro_plan_id IS NOT NULL AND reports_feature_id IS NOT NULL THEN
        INSERT INTO public.plan_features (plan_id, feature_id) VALUES (pro_plan_id, reports_feature_id) ON CONFLICT DO NOTHING;
    END IF;
     IF pro_plan_id IS NOT NULL AND movable_widget_feature_id IS NOT NULL THEN
        INSERT INTO public.plan_features (plan_id, feature_id) VALUES (pro_plan_id, movable_widget_feature_id) ON CONFLICT DO NOTHING;
    END IF;
    -- Business Plan
    IF biz_plan_id IS NOT NULL AND reports_feature_id IS NOT NULL THEN
        INSERT INTO public.plan_features (plan_id, feature_id) VALUES (biz_plan_id, reports_feature_id) ON CONFLICT DO NOTHING;
    END IF;
    IF biz_plan_id IS NOT NULL AND automations_feature_id IS NOT NULL THEN
        INSERT INTO public.plan_features (plan_id, feature_id) VALUES (biz_plan_id, automations_feature_id) ON CONFLICT DO NOTHING;
    END IF;
     IF biz_plan_id IS NOT NULL AND movable_widget_feature_id IS NOT NULL THEN
        INSERT INTO public.plan_features (plan_id, feature_id) VALUES (biz_plan_id, movable_widget_feature_id) ON CONFLICT DO NOTHING;
    END IF;
END $$;


-- =============================================
-- SECTION 7: DEMO SETUP (OPTIONAL)
-- =============================================
-- This part is for setting up the public-facing demo widget.
-- 
-- IMPORTANT INSTRUCTIONS:
-- 1. Use the TreshTalk application UI to register a new user with the email 'user@example.com'.
-- 2. Go to your email and click the verification link sent by Supabase.
-- 3. AFTER the user is created and verified, run the single command below in your SQL Editor.
-- 
-- UPDATE public.workspaces
-- SET widget_id = 'demo-widget-id'
-- WHERE owner_id = (SELECT id FROM auth.users WHERE email = 'user@example.com');


-- =============================================
-- SECTION 8: PERMISSIONS
-- =============================================
-- Grant usage on schema to anon and authenticated roles
GRANT USAGE ON SCHEMA public TO anon, authenticated;

-- Grant select on all tables to anon and authenticated roles
-- RLS policies will still control what they can see.
GRANT SELECT ON ALL TABLES IN SCHEMA public TO anon, authenticated;

-- Grant other permissions for authenticated users
GRANT INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO authenticated;
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public to authenticated;
